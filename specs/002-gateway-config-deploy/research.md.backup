# Research Report: CLI Tool Design for Gateway Configuration Deployment

**Feature**: 002-gateway-config-deploy  
**Date**: 2025-12-02  
**Status**: Complete

---

## Executive Summary

After researching Python CLI frameworks, interactive prompt libraries, progress indicators, and cross-platform best practices, I recommend **Typer + Rich** as the optimal stack for building the LLM Gateway Configuration deployment tool. This combination provides excellent developer experience, beautiful terminal output, and native support for both interactive and CI/CD modes.

**Key Recommendations:**
1. **CLI Framework**: Typer (over Click or argparse)
2. **Interactive Prompts**: Rich's built-in `Prompt` and `Confirm` (avoid questionary/inquirer overhead)
3. **Progress Indicators**: Rich's `Progress` with custom columns
4. **Path Handling**: Python's `pathlib.Path` with `expanduser()` for cross-platform support
5. **Architecture**: Support both interactive and `--yes` non-interactive modes from day one

---

## 1. CLI Framework Comparison

### Decision: Typer ‚úÖ

**Rationale:**
- Built on top of Click but adds **type hints** and automatic validation
- **Subcommands** are clean with decorators (vs argparse's verbose API)
- Auto-generates beautiful `--help` from docstrings and type annotations
- Native integration with Rich for colors/formatting
- Modern Python 3.7+ approach (matches our codebase)

**Comparison:**

| Feature | argparse | Click | Typer |
|---------|----------|-------|-------|
| Type hints | ‚ùå | ‚ùå | ‚úÖ |
| Subcommands | Verbose | Clean | Cleanest |
| Auto-validation | Manual | Manual | Automatic |
| Help generation | Basic | Good | Excellent |
| Rich integration | Manual | Manual | Native |
| Learning curve | Low | Medium | Low |

### Code Example: Typer CLI Structure

```python
#!/usr/bin/env python3
"""
LLM Gateway Configuration Deployment CLI
Usage: python deploy_gateway.py [OPTIONS] COMMAND [ARGS]
"""

import typer
from typing import Optional, List
from enum import Enum
from pathlib import Path
from rich.console import Console

app = typer.Typer(
    name="deploy-gateway",
    help="Deploy LLM Gateway configurations to Claude Code home directory",
    no_args_is_help=True,
)
console = Console()


class GatewayType(str, Enum):
    """Supported gateway types."""
    litellm = "litellm"
    enterprise = "enterprise"
    truefoundry = "truefoundry"
    custom = "custom"


class Preset(str, Enum):
    """Configuration presets."""
    basic = "basic"
    complete = "complete"
    minimal = "minimal"
    enterprise = "enterprise"


@app.command()
def deploy(
    preset: Preset = typer.Option(
        Preset.basic,
        "--preset", "-p",
        help="Configuration preset to deploy"
    ),
    models: Optional[List[str]] = typer.Option(
        None,
        "--models", "-m",
        help="Specific models to include (comma-separated)"
    ),
    gateway_type: GatewayType = typer.Option(
        GatewayType.litellm,
        "--gateway-type", "-g",
        help="Type of gateway to configure"
    ),
    update: bool = typer.Option(
        False,
        "--update", "-u",
        help="Update existing deployment (merge mode)"
    ),
    backup: bool = typer.Option(
        True,
        "--backup/--no-backup",
        help="Create backup before overwriting"
    ),
    yes: bool = typer.Option(
        False,
        "--yes", "-y",
        help="Skip interactive prompts (CI/CD mode)"
    ),
    target_dir: Optional[Path] = typer.Option(
        None,
        "--target-dir", "-t",
        help="Custom target directory (default: ~/.claude/gateway)"
    ),
):
    """
    Deploy gateway configuration files to Claude Code home directory.
    
    Examples:
    
        # Basic deployment with defaults
        $ deploy-gateway deploy
        
        # Deploy specific models only
        $ deploy-gateway deploy --models gemini-2.5-flash,deepseek-r1
        
        # Enterprise gateway setup
        $ deploy-gateway deploy --gateway-type enterprise --preset enterprise
        
        # Non-interactive mode for CI/CD
        $ deploy-gateway deploy --yes --preset complete
    """
    from .core import DeploymentManager
    
    # Resolve target directory
    if target_dir is None:
        target_dir = Path.home() / ".claude" / "gateway"
    else:
        target_dir = target_dir.expanduser()
    
    console.print(f"[bold blue]üöÄ Gateway Configuration Deployment[/bold blue]")
    console.print(f"Preset: [cyan]{preset.value}[/cyan]")
    console.print(f"Target: [cyan]{target_dir}[/cyan]")
    
    # Initialize deployment manager
    manager = DeploymentManager(
        preset=preset,
        models=models,
        gateway_type=gateway_type,
        target_dir=target_dir,
        backup=backup,
        interactive=not yes,
        console=console,
    )
    
    try:
        manager.run()
        console.print("\n[bold green]‚úÖ Deployment completed successfully![/bold green]")
    except KeyboardInterrupt:
        console.print("\n[yellow]‚ö†Ô∏è  Deployment cancelled by user[/yellow]")
        raise typer.Exit(1)
    except Exception as e:
        console.print(f"\n[bold red]‚ùå Deployment failed: {e}[/bold red]")
        raise typer.Exit(1)


@app.command()
def validate(
    config_file: Path = typer.Argument(
        ...,
        help="Path to configuration file to validate",
        exists=True,
    ),
    verbose: bool = typer.Option(
        False,
        "--verbose", "-v",
        help="Show detailed validation output"
    ),
):
    """Validate a gateway configuration file."""
    from .validation import validate_config
    
    console.print(f"[bold blue]üîç Validating: {config_file}[/bold blue]")
    
    is_valid, errors, warnings = validate_config(config_file)
    
    if errors:
        console.print(f"\n[bold red]‚ùå {len(errors)} error(s) found:[/bold red]")
        for error in errors:
            console.print(f"  ‚Ä¢ {error}")
    
    if warnings:
        console.print(f"\n[yellow]‚ö†Ô∏è  {len(warnings)} warning(s):[/yellow]")
        for warning in warnings:
            console.print(f"  ‚Ä¢ {warning}")
    
    if is_valid:
        console.print("\n[bold green]‚úÖ Configuration is valid![/bold green]")
        raise typer.Exit(0)
    else:
        raise typer.Exit(1)


@app.command()
def status():
    """Show current gateway deployment status."""
    from .status import get_deployment_status
    
    status_info = get_deployment_status()
    
    console.print("[bold blue]üìä Gateway Deployment Status[/bold blue]\n")
    
    if status_info["deployed"]:
        console.print(f"[green]‚úÖ Deployed[/green]")
        console.print(f"Location: [cyan]{status_info['path']}[/cyan]")
        console.print(f"Config: [cyan]{status_info['preset']}[/cyan]")
        console.print(f"Models: {status_info['model_count']}")
    else:
        console.print("[yellow]‚ö†Ô∏è  No deployment found[/yellow]")
        console.print("\nRun [bold]deploy-gateway deploy[/bold] to get started")


if __name__ == "__main__":
    app()
```

**Key Benefits:**
- Type-safe with `Enum` for choices
- Auto-validation of file paths with `exists=True`
- Beautiful help text from docstrings
- Clean subcommand structure
- Rich integration for colored output

---

## 2. Interactive Prompts

### Decision: Rich's Built-in Prompt Classes ‚úÖ

**Rationale:**
- **No additional dependency** (already using Rich for progress bars)
- `Prompt.ask()` and `Confirm.ask()` cover 90% of use cases
- Simpler API than questionary/inquirer for our needs
- Consistent styling with progress bars
- Easy to disable with `--yes` flag

**Why NOT questionary/inquirer:**
- Additional dependency overhead
- More complex API for basic yes/no and text prompts
- Our use case is simple (confirm overwrites, select preset)

### Code Example: Interactive Prompts with Rich

```python
from rich.console import Console
from rich.prompt import Prompt, Confirm
from rich.panel import Panel
from pathlib import Path
from typing import Optional

console = Console()


class InteractivePrompter:
    """Handles user interactions with rich prompts."""
    
    def __init__(self, non_interactive: bool = False):
        self.non_interactive = non_interactive
    
    def confirm_overwrite(self, file_path: Path) -> bool:
        """Ask user if they want to overwrite an existing file."""
        if self.non_interactive:
            return True
        
        console.print(f"\n[yellow]‚ö†Ô∏è  File exists: {file_path}[/yellow]")
        return Confirm.ask(
            "Overwrite existing file?",
            default=False,
        )
    
    def select_action(self, file_path: Path) -> str:
        """Let user choose action for existing file."""
        if self.non_interactive:
            return "backup"
        
        console.print(Panel(
            f"[yellow]File already exists:[/yellow]\n{file_path}\n\n"
            "Choose action:\n"
            "  [cyan]backup[/cyan]  - Create backup and overwrite\n"
            "  [cyan]merge[/cyan]   - Merge with existing config\n"
            "  [cyan]skip[/cyan]    - Skip this file\n"
            "  [cyan]cancel[/cyan]  - Abort deployment",
            title="Existing Configuration Detected",
        ))
        
        action = Prompt.ask(
            "Action",
            choices=["backup", "merge", "skip", "cancel"],
            default="backup",
        )
        
        if action == "cancel":
            raise KeyboardInterrupt("Deployment cancelled by user")
        
        return action
    
    def get_gateway_url(self) -> str:
        """Prompt for enterprise gateway URL."""
        if self.non_interactive:
            raise ValueError("Gateway URL required in non-interactive mode (use --gateway-url)")
        
        console.print("\n[bold]Enterprise Gateway Configuration[/bold]")
        url = Prompt.ask(
            "Gateway URL",
            default="https://gateway.company.com",
        )
        
        # Validate URL format
        if not url.startswith(("http://", "https://")):
            console.print("[red]‚ùå Invalid URL format[/red]")
            return self.get_gateway_url()  # Retry
        
        return url
    
    def select_models(self, available_models: list[str]) -> list[str]:
        """Let user select which models to deploy."""
        if self.non_interactive:
            return available_models  # Deploy all
        
        console.print("\n[bold]Available Models:[/bold]")
        for i, model in enumerate(available_models, 1):
            console.print(f"  {i}. {model}")
        
        console.print("\n[dim]Enter model numbers separated by commas (e.g., 1,3,5)[/dim]")
        console.print("[dim]Or press Enter to select all models[/dim]")
        
        selection = Prompt.ask(
            "Models to deploy",
            default="all",
        )
        
        if selection.lower() in ("all", ""):
            return available_models
        
        try:
            indices = [int(x.strip()) - 1 for x in selection.split(",")]
            return [available_models[i] for i in indices if 0 <= i < len(available_models)]
        except (ValueError, IndexError):
            console.print("[red]‚ùå Invalid selection[/red]")
            return self.select_models(available_models)  # Retry


# Usage example
def deploy_with_prompts():
    prompter = InteractivePrompter(non_interactive=False)
    
    # Check existing deployment
    target = Path.home() / ".claude" / "gateway" / "config.yaml"
    if target.exists():
        action = prompter.select_action(target)
        if action == "backup":
            create_backup(target)
        elif action == "skip":
            return
    
    # Model selection
    models = ["gemini-2.5-flash", "gemini-2.5-pro", "deepseek-r1"]
    selected = prompter.select_models(models)
    
    console.print(f"\n[green]‚úÖ Selected {len(selected)} models[/green]")
```

**Key Features:**
- `Confirm.ask()` for yes/no questions
- `Prompt.ask()` with choices for multiple options
- Input validation with retry logic
- Panel for rich formatting
- Easy to bypass with `--yes` flag

---

## 3. Progress Indicators

### Decision: Rich Progress with Custom Columns ‚úÖ

**Rationale:**
- **Rich's Progress** is production-ready and feature-complete
- Supports multiple concurrent tasks (copying files, validating, etc.)
- Custom columns for file names, sizes, and speeds
- Transient mode for clean output after completion
- Spinner support for indeterminate operations

### Code Example: Progress Indicators

```python
from rich.progress import (
    Progress,
    SpinnerColumn,
    TextColumn,
    BarColumn,
    TaskProgressColumn,
    TimeRemainingColumn,
    FileSizeColumn,
    TransferSpeedColumn,
)
from rich.console import Console
from pathlib import Path
import time
import shutil

console = Console()


def deploy_files_with_progress(source_files: list[Path], target_dir: Path):
    """Copy files with progress bar."""
    
    # Define custom progress display
    progress = Progress(
        SpinnerColumn(),
        TextColumn("[bold blue]{task.description}"),
        BarColumn(),
        TaskProgressColumn(),
        FileSizeColumn(),
        TransferSpeedColumn(),
        TimeRemainingColumn(),
        console=console,
        transient=False,  # Keep progress after completion
    )
    
    with progress:
        # Overall progress task
        overall_task = progress.add_task(
            "[cyan]Deploying configuration...",
            total=len(source_files)
        )
        
        for source_file in source_files:
            # Create task for this specific file
            file_size = source_file.stat().st_size
            file_task = progress.add_task(
                f"Copying {source_file.name}",
                total=file_size
            )
            
            # Copy file in chunks to show progress
            target_file = target_dir / source_file.name
            with open(source_file, 'rb') as src:
                with open(target_file, 'wb') as dst:
                    while True:
                        chunk = src.read(8192)
                        if not chunk:
                            break
                        dst.write(chunk)
                        progress.update(file_task, advance=len(chunk))
            
            # Mark file as complete
            progress.update(file_task, completed=file_size)
            progress.update(overall_task, advance=1)
            
            # Brief pause for visual feedback
            time.sleep(0.1)
    
    console.print("[green]‚úÖ All files deployed successfully[/green]")


def validate_with_spinner(config_file: Path):
    """Run validation with spinner for indeterminate operation."""
    
    with Progress(
        SpinnerColumn(),
        TextColumn("[bold blue]{task.description}"),
        transient=True,  # Remove after completion
        console=console,
    ) as progress:
        task = progress.add_task("Validating configuration...", total=None)
        
        # Simulate validation steps
        validation_steps = [
            "Checking YAML syntax",
            "Validating model configurations",
            "Checking environment variables",
            "Verifying gateway connectivity",
        ]
        
        for step in validation_steps:
            progress.update(task, description=f"[bold blue]{step}...")
            time.sleep(0.5)  # Replace with actual validation
    
    console.print("[green]‚úÖ Configuration is valid[/green]")


def multi_stage_deployment():
    """Show multiple concurrent progress bars."""
    
    with Progress(
        SpinnerColumn(),
        TextColumn("[bold]{task.description}"),
        BarColumn(),
        TaskProgressColumn(),
        console=console,
    ) as progress:
        # Stage 1: Pre-flight checks
        checks_task = progress.add_task("[cyan]Pre-flight checks", total=3)
        progress.update(checks_task, advance=1, description="[cyan]‚úì Checking target directory")
        progress.update(checks_task, advance=1, description="[cyan]‚úì Validating source files")
        progress.update(checks_task, advance=1, description="[cyan]‚úì Checking permissions")
        
        # Stage 2: File operations
        files_task = progress.add_task("[yellow]Copying files", total=5)
        for i in range(5):
            time.sleep(0.2)
            progress.update(files_task, advance=1)
        
        # Stage 3: Configuration
        config_task = progress.add_task("[magenta]Configuring environment", total=2)
        progress.update(config_task, advance=1, description="[magenta]Setting env vars")
        progress.update(config_task, advance=1, description="[magenta]Updating settings")
    
    console.print("\n[bold green]üéâ Deployment complete![/bold green]")


# Compact progress for quiet mode
def copy_files_quietly(source_files: list[Path], target_dir: Path):
    """Minimal progress output for CI/CD."""
    
    console.print(f"Deploying {len(source_files)} files...")
    
    for i, source_file in enumerate(source_files, 1):
        target_file = target_dir / source_file.name
        shutil.copy2(source_file, target_file)
        console.print(f"  [{i}/{len(source_files)}] {source_file.name}")
    
    console.print("‚úÖ Done")
```

**Key Features:**
- Multiple concurrent progress bars
- File size and transfer speed display
- Spinner for indeterminate operations
- Transient mode for clean terminal
- Customizable columns per use case

---

## 4. Cross-Platform Path Handling

### Decision: pathlib.Path with expanduser() ‚úÖ

**Rationale:**
- **pathlib** is built-in (Python 3.4+) and cross-platform
- `Path.home()` works on Windows, macOS, Linux
- `expanduser()` handles `~` in user-provided paths
- Forward slashes work on all platforms (pathlib normalizes)
- Clean API vs `os.path` string manipulation

### Code Example: Cross-Platform Paths

```python
from pathlib import Path
import os
import sys
from typing import Optional


def resolve_target_directory(custom_path: Optional[str] = None) -> Path:
    """
    Resolve target directory with cross-platform support.
    
    Args:
        custom_path: User-provided path (may contain ~)
    
    Returns:
        Absolute Path object
    """
    if custom_path:
        # Handle user-provided path
        target = Path(custom_path).expanduser().resolve()
    else:
        # Default: ~/.claude/gateway
        target = Path.home() / ".claude" / "gateway"
    
    return target


def ensure_directory_exists(path: Path) -> None:
    """Create directory if it doesn't exist (cross-platform)."""
    path.mkdir(parents=True, exist_ok=True)


def get_config_file_path(base_dir: Path, filename: str) -> Path:
    """Get config file path (handles both / and \ separators)."""
    return base_dir / filename  # Works on all platforms


def backup_file(file_path: Path) -> Path:
    """Create timestamped backup (cross-platform)."""
    from datetime import datetime
    
    timestamp = datetime.now().strftime("%Y%m%d-%H%M%S")
    backup_path = file_path.with_suffix(f".{timestamp}{file_path.suffix}")
    
    # Use shutil for reliable cross-platform copy
    import shutil
    shutil.copy2(file_path, backup_path)
    
    return backup_path


def find_shell_config_file() -> Optional[Path]:
    """Find appropriate shell config file (platform-aware)."""
    home = Path.home()
    
    # Detect shell
    shell = os.environ.get("SHELL", "")
    
    if sys.platform == "win32":
        # Windows: PowerShell profile
        return home / "Documents" / "WindowsPowerShell" / "profile.ps1"
    
    elif "zsh" in shell:
        # macOS default (Catalina+) and some Linux
        return home / ".zshrc"
    
    else:
        # Linux default and older macOS
        return home / ".bashrc"


def make_executable(script_path: Path) -> None:
    """Make script executable (Unix-like only)."""
    if sys.platform != "win32":
        import stat
        current_mode = script_path.stat().st_mode
        script_path.chmod(current_mode | stat.S_IXUSR | stat.S_IXGRP | stat.S_IXOTH)


def get_platform_info() -> dict:
    """Get platform-specific information."""
    return {
        "platform": sys.platform,
        "os_name": os.name,
        "home_dir": str(Path.home()),
        "shell": os.environ.get("SHELL", "unknown"),
        "is_windows": sys.platform == "win32",
        "is_macos": sys.platform == "darwin",
        "is_linux": sys.platform.startswith("linux"),
    }


# Example usage
def main():
    # Cross-platform path resolution
    target_dir = resolve_target_directory("~/.claude/gateway")
    ensure_directory_exists(target_dir)
    
    config_file = get_config_file_path(target_dir, "litellm_config.yaml")
    
    # Create backup if file exists
    if config_file.exists():
        backup_path = backup_file(config_file)
        print(f"Created backup: {backup_path}")
    
    # Platform-specific handling
    platform = get_platform_info()
    if platform["is_windows"]:
        print("Running on Windows - using PowerShell config")
    elif platform["is_macos"]:
        print("Running on macOS - using .zshrc")
    else:
        print("Running on Linux - using .bashrc")
    
    # Find shell config
    shell_config = find_shell_config_file()
    if shell_config:
        print(f"Shell config: {shell_config}")
```

**Key Practices:**
- Always use `Path()` instead of string concatenation
- Use `Path.home()` not `os.path.expanduser("~")`
- Use `Path.mkdir(parents=True, exist_ok=True)` for safe creation
- Use `shutil` for file operations (more reliable than `Path.rename()`)
- Check `sys.platform` for OS-specific logic

---

## 5. Bash Script Cross-Platform Best Practices

### Code Example: Cross-Platform Bash

```bash
#!/usr/bin/env bash
# Cross-platform deployment script
# Works on macOS, Linux, and WSL

set -euo pipefail

# Color codes (work on most terminals)
if [[ -t 1 ]]; then
    RED='\033[0;31m'
    GREEN='\033[0;32m'
    YELLOW='\033[1;33m'
    BLUE='\033[0;34m'
    NC='\033[0m'
else
    # Non-interactive (CI/CD) - no colors
    RED=''
    GREEN=''
    YELLOW=''
    BLUE=''
    NC=''
fi

# Detect platform
detect_platform() {
    case "$(uname -s)" in
        Darwin*)
            echo "macos"
            ;;
        Linux*)
            echo "linux"
            ;;
        CYGWIN*|MINGW*|MSYS*)
            echo "windows"
            ;;
        *)
            echo "unknown"
            ;;
    esac
}

# Resolve home directory (cross-platform)
get_home_dir() {
    if [[ -n "${HOME:-}" ]]; then
        echo "$HOME"
    elif [[ -n "${USERPROFILE:-}" ]]; then
        # Windows fallback
        echo "$USERPROFILE"
    else
        echo ~
    fi
}

# Find shell config file
find_shell_config() {
    local home_dir=$(get_home_dir)
    local platform=$(detect_platform)
    
    # Check SHELL variable first
    if [[ "${SHELL:-}" == *"zsh"* ]] && [[ -f "$home_dir/.zshrc" ]]; then
        echo "$home_dir/.zshrc"
    elif [[ -f "$home_dir/.bashrc" ]]; then
        echo "$home_dir/.bashrc"
    elif [[ -f "$home_dir/.bash_profile" ]]; then
        echo "$home_dir/.bash_profile"
    elif [[ "$platform" == "macos" ]] && [[ -f "$home_dir/.zprofile" ]]; then
        echo "$home_dir/.zprofile"
    else
        echo "$home_dir/.profile"
    fi
}

# Check if command exists (cross-platform)
command_exists() {
    command -v "$1" >/dev/null 2>&1
}

# Create directory safely
ensure_dir() {
    local dir="$1"
    mkdir -p "$dir" 2>/dev/null || {
        echo -e "${RED}Error: Failed to create directory: $dir${NC}" >&2
        return 1
    }
}

# Copy file with progress
copy_file() {
    local source="$1"
    local target="$2"
    
    if [[ ! -f "$source" ]]; then
        echo -e "${RED}Error: Source file not found: $source${NC}" >&2
        return 1
    fi
    
    # Use rsync if available (shows progress), otherwise cp
    if command_exists rsync; then
        rsync -ah --progress "$source" "$target"
    else
        cp -v "$source" "$target"
    fi
}

# Main deployment logic
main() {
    local platform=$(detect_platform)
    local home_dir=$(get_home_dir)
    local target_dir="$home_dir/.claude/gateway"
    
    echo -e "${BLUE}üöÄ Gateway Configuration Deployment${NC}"
    echo -e "Platform: ${YELLOW}$platform${NC}"
    echo -e "Target: ${YELLOW}$target_dir${NC}"
    echo ""
    
    # Create target directory
    ensure_dir "$target_dir" || exit 1
    
    # Deploy files
    echo -e "${BLUE}Copying configuration files...${NC}"
    copy_file "templates/litellm_config.yaml" "$target_dir/litellm_config.yaml"
    copy_file "templates/.env.example" "$target_dir/.env"
    
    # Platform-specific post-install
    case "$platform" in
        macos)
            echo -e "${YELLOW}macOS detected - checking Homebrew...${NC}"
            if ! command_exists brew; then
                echo -e "${YELLOW}‚ö†Ô∏è  Homebrew not found. Install from https://brew.sh${NC}"
            fi
            ;;
        linux)
            echo -e "${YELLOW}Linux detected - checking Python...${NC}"
            if ! command_exists python3; then
                echo -e "${RED}‚ùå Python 3 required. Install with: sudo apt install python3${NC}"
                exit 1
            fi
            ;;
        windows)
            echo -e "${YELLOW}Windows detected - ensure WSL or Git Bash is being used${NC}"
            ;;
    esac
    
    # Add to shell config
    local shell_config=$(find_shell_config)
    echo -e "\n${BLUE}Shell configuration: ${YELLOW}$shell_config${NC}"
    
    if [[ -w "$shell_config" ]]; then
        if ! grep -q "ANTHROPIC_BASE_URL" "$shell_config" 2>/dev/null; then
            echo -e "\n# LLM Gateway Configuration" >> "$shell_config"
            echo "export ANTHROPIC_BASE_URL=\"http://localhost:4000\"" >> "$shell_config"
            echo -e "${GREEN}‚úÖ Added environment variable to $shell_config${NC}"
        else
            echo -e "${YELLOW}‚ö†Ô∏è  Environment variable already exists in $shell_config${NC}"
        fi
    fi
    
    echo -e "\n${GREEN}‚úÖ Deployment complete!${NC}"
    echo -e "\nNext steps:"
    echo -e "  1. Source your shell config: ${YELLOW}source $shell_config${NC}"
    echo -e "  2. Start LiteLLM: ${YELLOW}litellm --config $target_dir/litellm_config.yaml${NC}"
    echo -e "  3. Test with: ${YELLOW}claude /status${NC}"
}

# Run main function
main "$@"
```

**Key Cross-Platform Techniques:**
1. **Use `uname -s`** to detect OS (not `$OSTYPE` which varies)
2. **Check `$HOME` then `$USERPROFILE`** for Windows compatibility
3. **Use `command -v`** instead of `which` (more portable)
4. **Disable colors in non-TTY** for CI/CD logs
5. **Use `mkdir -p`** for safe directory creation
6. **Prefer `#!/usr/bin/env bash`** over `#!/bin/bash`

---

## 6. Interactive vs Non-Interactive Modes

### Best Practice: Support Both from Day One ‚úÖ

**Pattern:**

```python
class DeploymentManager:
    def __init__(self, interactive: bool = True):
        self.interactive = interactive
        self.prompter = InteractivePrompter(non_interactive=not interactive)
    
    def handle_existing_file(self, file_path: Path) -> str:
        """Handle existing file - interactive or auto-backup."""
        if not self.interactive:
            # CI/CD mode: always backup
            return "backup"
        else:
            # Interactive: ask user
            return self.prompter.select_action(file_path)
    
    def validate_prerequisites(self) -> bool:
        """Check prerequisites - fail fast in non-interactive."""
        missing = self.check_dependencies()
        
        if missing:
            if self.interactive:
                console.print("[yellow]‚ö†Ô∏è  Missing dependencies:[/yellow]")
                for dep in missing:
                    console.print(f"  ‚Ä¢ {dep}")
                
                if Confirm.ask("Install missing dependencies?", default=True):
                    self.install_dependencies(missing)
                    return True
                else:
                    return False
            else:
                # CI/CD: just fail with clear message
                console.print("[red]‚ùå Missing dependencies:[/red]")
                for dep in missing:
                    console.print(f"  ‚Ä¢ {dep}")
                console.print("\nInstall with: pip install " + " ".join(missing))
                return False
        
        return True
```

**CLI Flags:**
- `--yes` / `-y`: Skip all prompts (use defaults)
- `--quiet` / `-q`: Minimal output
- `--verbose` / `-v`: Detailed logging

---

## 7. Error Handling and Help Text

### Best Practices

```python
@app.command()
def deploy(
    preset: Preset = typer.Option(...),
    # ... other options
):
    """
    Deploy gateway configuration to Claude Code.
    
    This command copies configuration files from the templates directory
    to ~/.claude/gateway/ and sets up environment variables.
    
    \b
    Examples:
        Basic deployment (interactive):
        $ deploy-gateway deploy
        
        Quick deployment (skip prompts):
        $ deploy-gateway deploy --yes
        
        Specific models only:
        $ deploy-gateway deploy --models gemini-2.5-flash,deepseek-r1
        
        Enterprise gateway:
        $ deploy-gateway deploy --gateway-type enterprise --gateway-url https://gateway.company.com
    
    \b
    Notes:
        ‚Ä¢ Use --yes for CI/CD pipelines
        ‚Ä¢ Backups are created automatically (disable with --no-backup)
        ‚Ä¢ Existing configs are never overwritten without confirmation
    """
    try:
        # ... deployment logic
        pass
    except FileNotFoundError as e:
        console.print(f"[red]‚ùå File not found: {e.filename}[/red]")
        console.print("\nCheck that you're running from the correct directory:")
        console.print("  $ cd specs/001-llm-gateway-config")
        console.print("  $ deploy-gateway deploy")
        raise typer.Exit(1)
    
    except PermissionError as e:
        console.print(f"[red]‚ùå Permission denied: {e.filename}[/red]")
        console.print("\nTry:")
        console.print("  ‚Ä¢ Changing target directory: --target-dir ~/my-configs")
        console.print("  ‚Ä¢ Running with elevated privileges (not recommended)")
        raise typer.Exit(1)
    
    except KeyboardInterrupt:
        console.print("\n[yellow]‚ö†Ô∏è  Deployment cancelled by user[/yellow]")
        console.print("Partial changes may have been made. Run 'deploy-gateway status' to check.")
        raise typer.Exit(130)  # Standard exit code for SIGINT
```

**Help Text Best Practices:**
- Use `\b` to preserve formatting in examples
- Provide 3-5 concrete examples
- Document all flags with use cases
- Include troubleshooting hints in error messages
- Use consistent emoji for visual scanning

---

## 8. Recommended Project Structure

```
specs/002-gateway-config-deploy/
‚îú‚îÄ‚îÄ deploy_gateway.py          # Main CLI entry point
‚îú‚îÄ‚îÄ requirements.txt            # typer, rich, pyyaml, click
‚îú‚îÄ‚îÄ core/
‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îú‚îÄ‚îÄ deployment.py          # DeploymentManager class
‚îÇ   ‚îú‚îÄ‚îÄ validation.py          # Config validation
‚îÇ   ‚îú‚îÄ‚îÄ backup.py              # Backup management
‚îÇ   ‚îî‚îÄ‚îÄ env_vars.py            # Environment variable handling
‚îú‚îÄ‚îÄ prompts/
‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îî‚îÄ‚îÄ interactive.py         # InteractivePrompter class
‚îú‚îÄ‚îÄ utils/
‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îú‚îÄ‚îÄ paths.py               # Cross-platform path handling
‚îÇ   ‚îî‚îÄ‚îÄ platform.py            # Platform detection
‚îú‚îÄ‚îÄ tests/
‚îÇ   ‚îú‚îÄ‚îÄ test_deployment.py
‚îÇ   ‚îú‚îÄ‚îÄ test_paths.py
‚îÇ   ‚îî‚îÄ‚îÄ test_interactive.py
‚îî‚îÄ‚îÄ README.md
```

---

## 9. Dependencies

**requirements.txt:**
```txt
typer[all]>=0.9.0         # CLI framework with Rich support
rich>=13.0.0              # Terminal formatting and progress
pyyaml>=6.0               # YAML config parsing
click>=8.1.0              # Typer dependency (explicit for stability)
```

**Why these versions:**
- `typer[all]` includes Rich automatically
- Rich 13.0+ has stable Progress API
- PyYAML 6.0+ has security fixes

---

## 10. CI/CD Integration Pattern

### GitHub Actions Example

```yaml
name: Test Deployment

on: [push, pull_request]

jobs:
  test-deploy:
    runs-on: ${{ matrix.os }}
    strategy:
      matrix:
        os: [ubuntu-latest, macos-latest, windows-latest]
        python-version: ['3.9', '3.10', '3.11']
    
    steps:
      - uses: actions/checkout@v3
      
      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: ${{ matrix.python-version }}
      
      - name: Install dependencies
        run: |
          pip install -r requirements.txt
      
      - name: Test deployment (dry run)
        run: |
          python deploy_gateway.py deploy \
            --yes \
            --preset basic \
            --target-dir ./test-deployment \
            --no-backup
      
      - name: Validate deployed config
        run: |
          python deploy_gateway.py validate \
            ./test-deployment/litellm_config.yaml
```

---

## 11. Summary of Decisions

| Decision Point | Recommendation | Rationale |
|---------------|----------------|-----------|
| **CLI Framework** | Typer | Type hints, clean API, auto-validation |
| **Interactive Prompts** | Rich Prompt/Confirm | No extra deps, consistent styling |
| **Progress Bars** | Rich Progress | Feature-complete, customizable |
| **Path Handling** | pathlib.Path | Cross-platform, clean API |
| **Non-Interactive Mode** | `--yes` flag | CI/CD friendly |
| **Error Messages** | Rich console with hints | Better UX |
| **Help Text** | Typer docstrings + `\b` | Auto-generated, formatted |

---

## 12. Next Steps

1. **Create `deploy_gateway.py`** with Typer CLI structure
2. **Implement `DeploymentManager`** class with progress bars
3. **Add `InteractivePrompter`** for user interactions
4. **Write tests** for cross-platform path handling
5. **Create bash wrapper** for shell-based deployment
6. **Add `--dry-run`** flag for safe testing
7. **Document deployment scenarios** in README

---

## References

- **Typer Documentation**: https://typer.tiangolo.com/
- **Rich Documentation**: https://rich.readthedocs.io/
- **Python pathlib**: https://docs.python.org/3/library/pathlib.html
- **Click Documentation**: https://click.palletsprojects.com/
- **Cross-platform Bash**: specs/001-llm-gateway-config/scripts/validate-all.sh

---

**Status**: ‚úÖ Research Complete - Ready for Implementation

---

# Research Report: YAML Configuration Merging & Update Strategies

**Feature**: 002-gateway-config-deploy (Update Functionality)  
**Date**: 2025-12-02  
**Status**: Complete  
**Focus**: FR-022 through FR-025 (Configuration Update Requirements)

---

## Executive Summary

After researching YAML merging libraries and configuration update strategies, I recommend **ruamel.yaml with three-way merge algorithm** for handling the `--update` flag. This approach preserves user customizations and comments while intelligently merging new template changes.

**Key Recommendations:**
1. **Library**: ruamel.yaml (preserves comments, formatting, round-trip safe)
2. **Merge Strategy**: Three-way merge with base config tracking
3. **Conflict Resolution**: Tiered (auto/warn/critical) with user precedence default
4. **Customization Detection**: Compare user config against stored base snapshot
5. **Model List Handling**: Append-only (preserve existing, add new)

---

## 1. Python Library Comparison for YAML Merging

### Decision: ruamel.yaml ‚úÖ

**Rationale:**
- **Preserves comments**: Critical for user-editable configuration files
- **Preserves formatting**: Maintains indentation, quotes, YAML style
- **Round-trip safe**: Read ‚Üí modify ‚Üí write without information loss
- **YAML 1.2 support**: More modern than PyYAML (YAML 1.1)
- **Active maintenance**: Regular updates and bug fixes

**Comparison:**

| Feature | PyYAML | ruamel.yaml | yq (CLI) |
|---------|---------|-------------|----------|
| Comment preservation | ‚ùå | ‚úÖ | ‚úÖ |
| Formatting preservation | ‚ùå | ‚úÖ | ‚úÖ |
| Round-trip safe | ‚ùå | ‚úÖ | ‚ö†Ô∏è |
| Python native | ‚úÖ | ‚úÖ | ‚ùå |
| YAML 1.2 support | ‚ùå | ‚úÖ | ‚úÖ |
| API complexity | Simple | Medium | N/A |
| Binary dependency | ‚ùå | ‚ùå | ‚úÖ |
| **Verdict** | ‚ùå Destroys comments | ‚úÖ **RECOMMENDED** | ‚ùå Not Python native |

**Installation:**
```bash
pip install ruamel.yaml
```

### Why Not PyYAML?

**Critical Issue**: PyYAML **destroys all comments** when parsing and re-serializing YAML files.

**Example:**
```yaml
# Input file with comments
model_list:
  # Production model for API calls
  - model_name: gemini-2.5-flash
    litellm_params:
      model: vertex_ai/gemini-2.5-flash
      timeout: 60  # Increased for large requests
```

**After PyYAML round-trip:**
```yaml
model_list:
- litellm_params:
    model: vertex_ai/gemini-2.5-flash
    timeout: 60
  model_name: gemini-2.5-flash
```

**Result**: All comments lost, formatting changed, key order modified ‚Üí **Unacceptable for user configs**.

### Why Not yq CLI Tool?

**Issues:**
- Requires Go binary (external dependency, platform-specific)
- Not native Python integration (subprocess overhead)
- Overkill for programmatic merging
- Better for manual CLI operations

---

## 2. Merge Strategy: Smart Three-Way Merge

### Decision: Three-Way Merge with Base Tracking ‚úÖ

**Concept**: Track three versions to detect user customizations:
1. **Base Config**: Original template deployed (stored as snapshot)
2. **User Config**: Current config with user modifications
3. **New Config**: New template version to deploy

**Algorithm Logic:**
```
For each configuration key:
  If user_value != base_value:
    ‚Üí User customization detected ‚Üí PRESERVE user value
  Else if key exists in new config:
    ‚Üí No user customization ‚Üí Apply new default
  Else:
    ‚Üí Keep existing value
```

**Why Three-Way?**
- **Two-way merge** (user + new): Cannot detect if user customized a value
- **Simple overwrite**: Destroys all user customizations
- **Three-way merge**: Accurately identifies what user changed vs template updates

### Implementation: ConfigMergeStrategy Class

```python
class ConfigMergeStrategy:
    """
    Smart three-way merge for gateway configurations.
    Preserves user customizations while applying template updates.
    """
    
    MERGE_STRATEGIES = {
        'model_list': 'append',        # Add new models, keep existing
        'litellm_settings': 'deep',    # Deep merge settings
        'router_settings': 'deep',     # Deep merge router config
        'general_settings': 'preserve', # Don't override user settings
        'environment_variables': 'preserve' # Keep custom env vars
    }
    
    @staticmethod
    def merge(base_config, user_config, new_config):
        """
        Three-way merge preserving user customizations.
        
        Args:
            base_config: Original deployed template (or None if first deploy)
            user_config: Current config with user modifications
            new_config: New template to merge in
            
        Returns:
            merged_config: Result with user customizations preserved
            conflicts: List of conflicts requiring user resolution
        """
        if base_config is None:
            # First-time deployment or base unknown
            return ConfigMergeStrategy._merge_without_base(user_config, new_config)
        
        merged = {}
        conflicts = []
        
        for key in set(list(user_config.keys()) + list(new_config.keys())):
            strategy = ConfigMergeStrategy.MERGE_STRATEGIES.get(key, 'deep')
            
            if key == 'model_list':
                merged[key], key_conflicts = ConfigMergeStrategy._merge_model_list(
                    base_config.get(key, []),
                    user_config.get(key, []),
                    new_config.get(key, [])
                )
                conflicts.extend(key_conflicts)
                
            elif strategy == 'preserve':
                # User settings take precedence
                merged[key] = user_config.get(key, new_config.get(key))
                
            elif strategy == 'deep':
                merged[key], key_conflicts = ConfigMergeStrategy._deep_merge(
                    base_config.get(key, {}),
                    user_config.get(key, {}),
                    new_config.get(key, {})
                )
                conflicts.extend([(key, c) for c in key_conflicts])
                
            else:
                merged[key] = new_config.get(key, user_config.get(key))
        
        return merged, conflicts
    
    @staticmethod
    def _merge_model_list(base_models, user_models, new_models):
        """
        Merge model lists intelligently:
        - Keep all user models (including custom ones)
        - Add new models from template
        - Update model configs only if user hasn't customized
        """
        conflicts = []
        merged_models = []
        user_model_map = {m['model_name']: m for m in user_models}
        base_model_map = {m['model_name']: m for m in base_models}
        new_model_map = {m['model_name']: m for m in new_models}
        
        # Process all unique model names
        all_model_names = set(list(user_model_map.keys()) + list(new_model_map.keys()))
        
        for model_name in all_model_names:
            user_model = user_model_map.get(model_name)
            base_model = base_model_map.get(model_name)
            new_model = new_model_map.get(model_name)
            
            if user_model and model_name not in new_model_map:
                # User-added custom model - preserve it
                merged_models.append(user_model)
                
            elif user_model and new_model:
                # Model exists in both - check for customizations
                if base_model and user_model != base_model:
                    # User customized this model - preserve customizations
                    merged_model, model_conflicts = ConfigMergeStrategy._deep_merge(
                        base_model, user_model, new_model
                    )
                    merged_models.append(merged_model)
                    if model_conflicts:
                        conflicts.append((model_name, model_conflicts))
                else:
                    # No customization or unknown base - use new template
                    merged_models.append(new_model)
                    
            elif new_model:
                # New model from template - add it
                merged_models.append(new_model)
        
        return merged_models, conflicts
    
    @staticmethod
    def _deep_merge(base_dict, user_dict, new_dict):
        """
        Recursively merge nested dictionaries with customization detection.
        
        Logic per key:
        - If user value != base value: USER CUSTOMIZED ‚Üí preserve user value
        - Elif key in new config: apply new default
        - Else: keep user value
        """
        conflicts = []
        merged = {}
        
        all_keys = set(list(user_dict.keys()) + list(new_dict.keys()))
        
        for key in all_keys:
            user_val = user_dict.get(key)
            base_val = base_dict.get(key)
            new_val = new_dict.get(key)
            
            # Check if user customized this key
            user_customized = (user_val is not None and 
                              base_val is not None and 
                              user_val != base_val)
            
            if user_customized:
                # User modification detected
                if new_val != base_val:
                    # Template also changed - conflict!
                    conflicts.append({
                        'key': key,
                        'base': base_val,
                        'user': user_val,
                        'new': new_val,
                        'resolution': 'user_precedence'  # Default to keeping user value
                    })
                merged[key] = user_val  # Preserve user customization
                
            elif isinstance(user_val, dict) and isinstance(new_val, dict):
                # Both are dicts - recurse
                merged[key], nested_conflicts = ConfigMergeStrategy._deep_merge(
                    base_dict.get(key, {}),
                    user_val,
                    new_val
                )
                conflicts.extend([{**c, 'key': f"{key}.{c['key']}"} for c in nested_conflicts])
                
            else:
                # No user customization - use new value if available
                merged[key] = new_val if new_val is not None else user_val
        
        return merged, conflicts
    
    @staticmethod
    def _merge_without_base(user_config, new_config):
        """
        Fallback merge when base config is unknown.
        More conservative - preserves more user values.
        """
        # Conservative strategy: only add new top-level keys
        # Deep merge each section with user precedence
        merged = user_config.copy()
        conflicts = []
        
        for key, new_val in new_config.items():
            if key not in user_config:
                # New key - safe to add
                merged[key] = new_val
            elif key == 'model_list':
                # Always append new models
                user_models = {m['model_name']: m for m in user_config[key]}
                for new_model in new_val:
                    if new_model['model_name'] not in user_models:
                        merged[key].append(new_model)
            # For other keys, keep user value (conservative)
        
        return merged, conflicts
```

---

## 3. Detecting User Customizations

### Strategy: Base Config Tracking with Metadata

**Implementation**: Store deployment metadata on initial deployment.

**Metadata File**: `~/.claude/gateway/.deployment-metadata.json`

```json
{
  "template_version": "1.0.0",
  "deployed_at": "2025-12-02T10:30:00Z",
  "template_source": "specs/001-llm-gateway-config/templates/litellm-base.yaml",
  "template_hash": "a3f5b2c8...",
  "base_config_snapshot": {
    "model_list": [...],
    "litellm_settings": {...}
  }
}
```

**Customization Detection Function:**

```python
def detect_customizations(base_config, current_config):
    """
    Identify which keys user has modified.
    Returns dict mapping key paths to modification details.
    """
    customizations = {}
    
    def compare_recursive(base, current, path=""):
        if type(base) != type(current):
            customizations[path] = {
                'base_type': type(base).__name__,
                'current_type': type(current).__name__,
                'action': 'type_changed'
            }
            return
        
        if isinstance(base, dict):
            for key in set(list(base.keys()) + list(current.keys())):
                key_path = f"{path}.{key}" if path else key
                
                if key not in base:
                    customizations[key_path] = {
                        'action': 'added',
                        'value': current[key]
                    }
                elif key not in current:
                    customizations[key_path] = {
                        'action': 'removed',
                        'base_value': base[key]
                    }
                else:
                    compare_recursive(base[key], current[key], key_path)
        
        elif isinstance(base, list):
            # For lists, use more sophisticated comparison
            # (model lists need special handling)
            if base != current:
                customizations[path] = {
                    'action': 'list_modified',
                    'base_length': len(base),
                    'current_length': len(current)
                }
        
        elif base != current:
            customizations[path] = {
                'action': 'value_changed',
                'base_value': base,
                'current_value': current
            }
    
    compare_recursive(base_config, current_config)
    return customizations
```

**Usage Example:**

```python
# Load base snapshot from metadata
with open('~/.claude/gateway/.deployment-metadata.json') as f:
    metadata = json.load(f)
    base_config = metadata['base_config_snapshot']

# Load current user config
with open('~/.claude/gateway/litellm_config.yaml') as f:
    user_config = yaml.safe_load(f)

# Detect customizations
customizations = detect_customizations(base_config, user_config)

# Example output:
# {
#   'litellm_settings.timeout': {
#     'action': 'value_changed',
#     'base_value': 30,
#     'current_value': 60
#   },
#   'model_list': {
#     'action': 'list_modified',
#     'base_length': 1,
#     'current_length': 2
#   }
# }
```

---

## 4. Conflict Resolution Approach

### Strategy: Tiered Resolution (Auto/Warn/Critical)

**Philosophy**: Maximize automation while ensuring safety for critical settings.

**Resolution Tiers:**

| Tier | Trigger | Action | User Input |
|------|---------|--------|------------|
| **Auto** | Non-critical value conflicts | Preserve user value | No |
| **Warn** | Structural changes, deprecations | Preserve user value + warning | No |
| **Critical** | Security settings, breaking changes | Block deployment | Yes (required) |

**Critical Keys** (require user confirmation):
- `general_settings.master_key`
- `general_settings.database_url`
- `litellm_settings.set_verbose` (security: prevents debug in prod)
- Auth-related settings

### Implementation: ConflictResolver Class

```python
class ConflictResolver:
    """Handles merge conflicts with tiered resolution."""
    
    CRITICAL_KEYS = [
        'general_settings.master_key',
        'general_settings.database_url',
        'litellm_settings.set_verbose'
    ]
    
    @staticmethod
    def resolve_conflicts(conflicts, interactive=True):
        """
        Resolve merge conflicts using tiered strategy.
        
        Args:
            conflicts: List of conflict dicts from merge operation
            interactive: If True, prompt user for critical conflicts
            
        Returns:
            resolutions: Dict mapping conflict paths to chosen values
            blocked: List of conflicts that blocked deployment (if any)
        """
        resolutions = {}
        blocked = []
        
        for conflict in conflicts:
            severity = ConflictResolver._assess_severity(conflict)
            
            if severity == 'auto':
                # Auto-resolve: user precedence
                resolutions[conflict['key']] = conflict['user']
                
            elif severity == 'warn':
                # Warn but proceed with user value
                print(f"‚ö†Ô∏è  Warning: {conflict['key']} changed in template but keeping your value")
                print(f"   Your value: {conflict['user']}")
                print(f"   New template: {conflict['new']}")
                resolutions[conflict['key']] = conflict['user']
                
            elif severity == 'critical':
                if interactive:
                    # Prompt user
                    choice = ConflictResolver._prompt_user(conflict)
                    resolutions[conflict['key']] = choice
                else:
                    # Non-interactive mode: block deployment
                    blocked.append(conflict)
                    print(f"‚ùå Critical conflict at {conflict['key']} - manual resolution required")
        
        return resolutions, blocked
    
    @staticmethod
    def _assess_severity(conflict):
        """Determine if conflict is auto-resolvable, warning, or critical."""
        key = conflict['key']
        
        # Critical paths require user decision
        if any(key.startswith(ck) for ck in ConflictResolver.CRITICAL_KEYS):
            return 'critical'
        
        # Type changes are warnings
        if conflict.get('action') == 'type_changed':
            return 'warn'
        
        # Most value changes auto-resolve
        return 'auto'
    
    @staticmethod
    def _prompt_user(conflict):
        """Interactive prompt for critical conflict resolution."""
        print(f"\nüî• Critical conflict at: {conflict['key']}")
        print(f"   Base value:     {conflict['base']}")
        print(f"   Your value:     {conflict['user']} (current)")
        print(f"   Template value: {conflict['new']} (new)")
        print("\nChoose resolution:")
        print("  1) Keep your value (recommended)")
        print("  2) Use new template value")
        print("  3) Enter custom value")
        
        while True:
            choice = input("Enter choice (1-3): ").strip()
            if choice == '1':
                return conflict['user']
            elif choice == '2':
                return conflict['new']
            elif choice == '3':
                custom = input("Enter custom value: ").strip()
                return custom
            else:
                print("Invalid choice. Try again.")
```

**Example Output:**

```bash
$ python deploy-gateway.py --update

üìä Analyzing configuration changes...
‚úÖ Base config loaded from metadata
‚úÖ User config loaded: ~/.claude/gateway/litellm_config.yaml
‚úÖ New template loaded: templates/litellm-base.yaml

üîç Detected customizations:
   - litellm_settings.timeout: 30 ‚Üí 60 (user modified)
   - model_list: Added custom-model

‚ö†Ô∏è  Warning: litellm_settings.num_retries changed in template but keeping your value
   Your value: 3
   New template: 5
   (Use --force-defaults to override)

üìù Merge preview:
   ‚úÖ Preserve timeout=60 (user customization)
   ‚úÖ Add new model: deepseek-r1
   ‚úÖ Keep custom model: my-custom-model
   ‚¨ÜÔ∏è  Update num_retries: 3 (keeping yours, template suggests 5)

Continue with merge? [Y/n]: y

‚ú® Merge successful!
üíæ Backup created: ~/.claude/gateway/backups/config-20251202-103045.yaml
üìÑ Config updated: ~/.claude/gateway/litellm_config.yaml
```

---

## 5. Preserving YAML Comments with ruamel.yaml

### Implementation: CommentPreservingMerger Class

```python
from ruamel.yaml import YAML

class CommentPreservingMerger:
    """Merge YAML configs while preserving comments and formatting."""
    
    def __init__(self):
        self.yaml = YAML()
        self.yaml.preserve_quotes = True
        self.yaml.width = 4096  # Prevent line wrapping
        self.yaml.indent(mapping=2, sequence=2, offset=0)
    
    def merge_files(self, user_config_path, new_config_path, output_path):
        """
        Merge configurations preserving comments from user config.
        """
        # Load with comments preserved
        with open(user_config_path) as f:
            user_config = self.yaml.load(f)
        
        with open(new_config_path) as f:
            new_config = self.yaml.load(f)
        
        # Load base from metadata if available
        base_config = self._load_base_config()
        
        # Perform smart merge (using ConfigMergeStrategy from above)
        merged, conflicts = ConfigMergeStrategy.merge(
            base_config=base_config,
            user_config=dict(user_config),
            new_config=dict(new_config)
        )
        
        # Apply merge results to user_config object (preserves comments)
        self._apply_merge_preserving_structure(user_config, merged)
        
        # Resolve conflicts
        if conflicts:
            resolutions, blocked = ConflictResolver.resolve_conflicts(conflicts)
            if blocked:
                raise ValueError(f"Unresolved conflicts: {blocked}")
            self._apply_resolutions(user_config, resolutions)
        
        # Write back with comments preserved
        with open(output_path, 'w') as f:
            self.yaml.dump(user_config, f)
        
        return conflicts
    
    def _apply_merge_preserving_structure(self, target, merged_data):
        """
        Apply merged data to target while preserving CommentedMap structure.
        This keeps comments and formatting intact.
        """
        for key, value in merged_data.items():
            if isinstance(value, dict) and key in target and isinstance(target[key], dict):
                # Recursive merge for nested dicts
                self._apply_merge_preserving_structure(target[key], value)
            elif isinstance(value, list) and key == 'model_list':
                # Special handling for model list
                self._merge_model_list_preserve_comments(target, value)
            else:
                # Direct assignment (preserves comments on key if it exists)
                target[key] = value
    
    def _merge_model_list_preserve_comments(self, target_config, merged_models):
        """
        Update model_list while preserving comments on existing models.
        """
        if 'model_list' not in target_config:
            target_config['model_list'] = merged_models
            return
        
        existing_models = target_config['model_list']
        existing_names = {m['model_name']: i for i, m in enumerate(existing_models)}
        
        # Update existing models in place (preserves their comments)
        for merged_model in merged_models:
            name = merged_model['model_name']
            if name in existing_names:
                idx = existing_names[name]
                # Update in place to keep comments
                for key, value in merged_model.items():
                    existing_models[idx][key] = value
            else:
                # New model - append
                existing_models.append(merged_model)
    
    def _load_base_config(self):
        """Load base config from deployment metadata."""
        metadata_path = os.path.expanduser('~/.claude/gateway/.deployment-metadata.json')
        if not os.path.exists(metadata_path):
            return None
        
        with open(metadata_path) as f:
            metadata = json.load(f)
            return metadata.get('base_config_snapshot')
```

**Usage Example:**

```python
merger = CommentPreservingMerger()
conflicts = merger.merge_files(
    user_config_path='~/.claude/gateway/litellm_config.yaml',
    new_config_path='templates/litellm-base.yaml',
    output_path='~/.claude/gateway/litellm_config.yaml'
)

if conflicts:
    print(f"‚úÖ Merged with {len(conflicts)} conflicts auto-resolved")
```

---

## 6. Complete Merge Example

### Scenario

User has customized timeout and added custom model. New template adds new model and changes retry count.

**Base Config** (originally deployed):
```yaml
# LiteLLM Configuration
model_list:
  - model_name: gemini-2.5-flash
    litellm_params:
      model: vertex_ai/gemini-2.5-flash
      vertex_project: my-project

litellm_settings:
  drop_params: true
  set_verbose: false
  num_retries: 3      # Original default
  timeout: 30         # Original default
```

**User Config** (current, with customizations):
```yaml
# LiteLLM Configuration
model_list:
  - model_name: gemini-2.5-flash
    litellm_params:
      model: vertex_ai/gemini-2.5-flash
      vertex_project: my-project
  
  # My custom model for testing
  - model_name: my-custom-model
    litellm_params:
      model: vertex_ai/gemini-1.5-pro
      vertex_project: my-test-project

litellm_settings:
  drop_params: true
  set_verbose: false
  num_retries: 3
  timeout: 60          # USER CUSTOMIZED: increased from 30 to 60
```

**New Template Config**:
```yaml
# LiteLLM Configuration - Updated
model_list:
  - model_name: gemini-2.5-flash
    litellm_params:
      model: vertex_ai/gemini-2.5-flash
      vertex_project: YOUR_PROJECT_ID
  
  - model_name: deepseek-r1      # NEW MODEL
    litellm_params:
      model: vertex_ai/deepseek-r1
      vertex_project: YOUR_PROJECT_ID

litellm_settings:
  drop_params: true
  set_verbose: false
  num_retries: 5      # CHANGED: increased from 3 to 5
  timeout: 30         # Template default
```

**Merged Result** (after smart merge):
```yaml
# LiteLLM Configuration
model_list:
  - model_name: gemini-2.5-flash
    litellm_params:
      model: vertex_ai/gemini-2.5-flash
      vertex_project: my-project     # PRESERVED: user's project
  
  # My custom model for testing
  - model_name: my-custom-model      # PRESERVED: user's custom model
    litellm_params:
      model: vertex_ai/gemini-1.5-pro
      vertex_project: my-test-project
  
  - model_name: deepseek-r1          # ADDED: new model from template
    litellm_params:
      model: vertex_ai/deepseek-r1
      vertex_project: my-project     # Uses user's project

litellm_settings:
  drop_params: true
  set_verbose: false
  num_retries: 5      # UPDATED: template changed this, user hadn't customized
  timeout: 60         # PRESERVED: user customization detected (60 != 30)
```

**Merge Log:**
```
‚úÖ Merged successfully
üìù Changes applied:
   - Added 1 new model: deepseek-r1
   - Preserved 1 custom model: my-custom-model
   - Updated 1 setting: num_retries (3 ‚Üí 5)
   - Preserved 1 customization: timeout (kept your value: 60)
   
‚ö†Ô∏è  Note: Your 'timeout' value (60) differs from new template default (30).
    Keeping your customization. Use --force-defaults to override.
```

---

## 7. Implementation Recommendations

### Phase 1: Foundation (P1 - MVP)

**Tasks:**
1. Install `ruamel.yaml` dependency
   ```bash
   pip install ruamel.yaml
   ```

2. Create merger module structure:
   ```bash
   mkdir -p specs/002-gateway-config-deploy/deploy
   touch specs/002-gateway-config-deploy/deploy/{__init__,merger,conflict,metadata}.py
   ```

3. Implement `ConfigMergeStrategy` class:
   - `_deep_merge()` with customization detection
   - `_merge_model_list()` with append logic
   - Unit tests with example configs

4. Implement base config tracking:
   - Create `.deployment-metadata.json` schema
   - Store on initial deployment
   - Load and validate on update

5. Add comment preservation:
   - Create `CommentPreservingMerger` class
   - Test round-trip with comments
   - Verify formatting preservation

**Acceptance Criteria:**
- ‚úÖ Merge preserves user customizations
- ‚úÖ Merge adds new models without removing existing
- ‚úÖ Comments and formatting preserved
- ‚úÖ Base metadata stored and loaded correctly

### Phase 2: Conflict Handling (P2)

**Tasks:**
1. Implement `ConflictResolver` class:
   - Tiered severity assessment
   - Interactive prompts for critical conflicts
   - Non-interactive mode (CI/CD)

2. Add conflict reporting:
   - Detailed conflict descriptions
   - Before/after preview
   - Recommended actions

3. Add `--force-defaults` flag:
   - Override all user customizations
   - Use new template values
   - Backup before override

4. Test edge cases:
   - Unknown base (first update without metadata)
   - Type changes (string ‚Üí dict)
   - Removed keys in new template

**Acceptance Criteria:**
- ‚úÖ Critical conflicts block non-interactive deployments
- ‚úÖ User can resolve conflicts interactively
- ‚úÖ `--force-defaults` works correctly
- ‚úÖ Fallback merge works without base config

### Phase 3: Safety & Validation (P2)

**Tasks:**
1. Pre-merge validation:
   - YAML syntax check
   - Required keys validation
   - Schema validation (if applicable)

2. Post-merge validation:
   - Run `validate-config.py`
   - Check for missing required fields
   - Verify model list integrity

3. Atomic write with backup:
   - Write to temporary file first
   - Validate temp file
   - Swap on success, rollback on error

4. Rollback capability:
   - `--rollback` flag to restore previous config
   - List available backups
   - Verify backup integrity before restore

**Acceptance Criteria:**
- ‚úÖ Invalid merge results rejected before writing
- ‚úÖ Automatic backup on every update
- ‚úÖ Rollback restores working configuration
- ‚úÖ No partial writes on error

### Phase 4: User Experience (P3)

**Tasks:**
1. Dry-run mode:
   - `--dry-run` flag shows preview
   - Display what would change
   - No files written

2. Detailed merge report:
   - Show customizations detected
   - List new additions
   - Highlight conflicts resolved

3. `--add-models` shortcut:
   - Quick way to add models only
   - Skip full template merge
   - Example: `--add-models llama3-405b,deepseek-r1`

4. Migration path:
   - Handle configs without metadata
   - Prompt to create metadata on first update
   - Conservative merge when base unknown

**Acceptance Criteria:**
- ‚úÖ Dry-run shows accurate preview
- ‚úÖ Merge report is clear and actionable
- ‚úÖ `--add-models` works correctly
- ‚úÖ Migration from non-tracked deployments works

### Code Structure

```
specs/002-gateway-config-deploy/
‚îú‚îÄ‚îÄ deploy/
‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îú‚îÄ‚îÄ merger.py              # ConfigMergeStrategy, CommentPreservingMerger
‚îÇ   ‚îú‚îÄ‚îÄ conflict.py            # ConflictResolver
‚îÇ   ‚îú‚îÄ‚îÄ metadata.py            # Deployment metadata tracking
‚îÇ   ‚îú‚îÄ‚îÄ validator.py           # Pre/post merge validation
‚îÇ   ‚îî‚îÄ‚îÄ backup.py              # Backup/rollback logic
‚îú‚îÄ‚îÄ scripts/
‚îÇ   ‚îú‚îÄ‚îÄ deploy-gateway.py      # Main deployment script (uses Typer)
‚îÇ   ‚îú‚îÄ‚îÄ merge-config.py        # Standalone merge utility
‚îÇ   ‚îî‚îÄ‚îÄ rollback-deployment.py # Rollback helper
‚îî‚îÄ‚îÄ tests/
    ‚îú‚îÄ‚îÄ test_merger.py         # Merge algorithm tests
    ‚îú‚îÄ‚îÄ test_conflict.py       # Conflict resolution tests
    ‚îú‚îÄ‚îÄ test_comment_preservation.py
    ‚îî‚îÄ‚îÄ fixtures/              # Test YAML files
        ‚îú‚îÄ‚îÄ base-config.yaml
        ‚îú‚îÄ‚îÄ user-config.yaml
        ‚îî‚îÄ‚îÄ new-config.yaml
```

---

## 8. Alternative Approaches (Rejected)

### JSON Merge Patch (RFC 7386) ‚ùå

**Why Rejected:**
- Designed for JSON, not YAML
- Doesn't preserve comments (JSON has no comments)
- Shallow merge semantics (replaces entire arrays)
- No built-in customization detection
- Would require conversion YAML ‚Üí JSON ‚Üí merge ‚Üí YAML

**Verdict**: Wrong tool for the job.

### deepmerge library ‚ùå

**Why Rejected:**
- Uses PyYAML underneath ‚Üí **destroys comments**
- No built-in conflict detection
- Simple recursive merge only
- Would need extensive wrapper code

**Verdict**: Insufficient for user-facing configs.

### Manual dict merging ‚ùå

**Why Rejected:**
- Complex to implement correctly
- Edge cases with nested structures (lists of dicts)
- No comment preservation
- No YAML-specific formatting preservation

**Verdict**: Reinventing the wheel poorly.

---

## 9. References

### Libraries
- **ruamel.yaml Documentation**: https://yaml.readthedocs.io/en/latest/
  - Round-trip YAML parser preserving comments
  - API Reference: https://yaml.readthedocs.io/en/latest/api.html
  - Examples: https://yaml.readthedocs.io/en/latest/example.html

- **PyYAML Documentation**: https://pyyaml.org/wiki/PyYAMLDocumentation
  - Standard YAML parser (comparison reference)

### Specifications
- **YAML 1.2 Specification**: https://yaml.org/spec/1.2/spec.html
- **JSON Merge Patch (RFC 7386)**: https://datatracker.ietf.org/doc/html/rfc7386
  - Reviewed but not suitable for our use case

### Merge Algorithms
- **Three-way merge**: https://en.wikipedia.org/wiki/Merge_(version_control)#Three-way_merge
- **Git merge strategies**: Inspiration for conflict detection
  - https://git-scm.com/docs/merge-strategies

### Best Practices
- **Configuration Management**: Infrastructure-as-code patterns
- **Round-trip YAML**: https://yaml.readthedocs.io/en/latest/detail.html#round-trip-including-comments

### Internal References
- LiteLLM config structure: `specs/001-llm-gateway-config/templates/*.yaml`
- Existing validation: `specs/001-llm-gateway-config/scripts/validate-config.py`
- Spec requirements: `specs/002-gateway-config-deploy/spec.md` (FR-022 to FR-025)

---

## 10. Next Steps

### Immediate Actions (This Sprint)

1. **Install and test ruamel.yaml**:
   ```bash
   pip install ruamel.yaml
   python3 -c "from ruamel.yaml import YAML; print('‚úÖ ruamel.yaml installed')"
   ```

2. **Create merger module skeleton**:
   ```bash
   mkdir -p specs/002-gateway-config-deploy/deploy
   touch specs/002-gateway-config-deploy/deploy/{__init__,merger,conflict,metadata,validator,backup}.py
   ```

3. **Create test fixtures**:
   ```bash
   mkdir -p specs/002-gateway-config-deploy/tests/fixtures
   # Copy example configs for testing
   ```

4. **Implement base tracking**:
   - Define `.deployment-metadata.json` schema
   - Add `save_metadata()` and `load_metadata()` functions
   - Store on initial deployment

5. **Prototype merge algorithm**:
   - Implement `ConfigMergeStrategy._deep_merge()` with tests
   - Test with example configs (base ‚Üí user ‚Üí new)
   - Verify customization detection works

6. **Test comment preservation**:
   - Create YAML file with comments
   - Round-trip through ruamel.yaml
   - Verify comments preserved

7. **Write unit tests**:
   ```bash
   # Create test files
   touch specs/002-gateway-config-deploy/tests/test_merger.py
   touch specs/002-gateway-config-deploy/tests/test_conflict.py
   touch specs/002-gateway-config-deploy/tests/test_comment_preservation.py
   ```

### Follow-up Research (Next Sprint)

1. **Conflict UI design**: 
   - How to present conflicts in CLI effectively?
   - Colors, formatting, clarity
   - Rich integration for better display

2. **Migration strategy**: 
   - Handle existing deployments without metadata
   - Prompt user workflow
   - Conservative merge defaults

3. **Performance testing**: 
   - Large configs (100+ models) merge speed
   - Memory usage with deep nesting
   - Optimization opportunities

4. **Backup retention policy**: 
   - How many backups to keep?
   - Automatic cleanup of old backups
   - Disk space management

### Integration Points

- **FR-022 to FR-025**: Specs aligned with merge strategy
- **deploy-gateway.py**: Integrate `CommentPreservingMerger`
- **validate-config.py**: Add as post-merge validation hook
- **Documentation**: 
  - User guide for merge behavior
  - Conflict resolution examples
  - Customization best practices

---

## 11. Decision Summary

### Final Decisions

‚úÖ **Library**: **ruamel.yaml**  
‚úÖ **Strategy**: **Three-way merge with base config tracking**  
‚úÖ **Conflict Resolution**: **Tiered (auto/warn/critical) with user precedence default**  
‚úÖ **Comment Preservation**: **Yes (via ruamel.yaml)**  
‚úÖ **Customization Detection**: **Compare against stored base snapshot**  
‚úÖ **Model List Handling**: **Append new models, preserve existing (including custom)**  
‚úÖ **Metadata Storage**: **`~/.claude/gateway/.deployment-metadata.json`**  

### Risk Assessment

**Overall Risk**: **LOW**

**Factors:**
- ‚úÖ ruamel.yaml is mature, well-maintained, widely used
- ‚úÖ Three-way merge is proven algorithm (used by Git, Mercurial)
- ‚úÖ Tiered conflict resolution provides safety net
- ‚úÖ Metadata tracking enables accurate diff detection
- ‚úÖ Fallback merge handles edge cases (no base)
- ‚ö†Ô∏è Complexity risk mitigated by comprehensive testing

**Mitigation:**
- Extensive unit tests covering edge cases
- Dry-run mode for safe preview
- Automatic backups before any write
- Rollback capability for recovery
- Validation before and after merge

### Implementation Effort

**Overall Effort**: **MEDIUM** (8-10 days)

**Breakdown:**
- **Phase 1** (Foundation): 3-4 days
  - Merger module: 2 days
  - Base tracking: 1 day
  - Comment preservation: 1 day

- **Phase 2** (Conflict Handling): 2-3 days
  - ConflictResolver: 1.5 days
  - Interactive prompts: 1 day
  - Edge case testing: 0.5 day

- **Phase 3** (Safety): 2-3 days
  - Validation: 1 day
  - Atomic writes + backup: 1 day
  - Rollback: 1 day

- **Phase 4** (UX): 1-2 days
  - Dry-run mode: 0.5 day
  - Merge report: 0.5 day
  - `--add-models` shortcut: 0.5 day
  - Documentation: 0.5 day

**Dependencies:**
- Typer CLI framework (already decided in previous research)
- Rich library for output formatting
- Existing validation scripts from 001-llm-gateway-config

**Team Impact:**
- Single developer can implement (well-defined scope)
- Reviewers need YAML knowledge (not Python-specific)
- Testing requires multiple config scenarios

---

**Status**: ‚úÖ Research Complete - Ready for Implementation Planning
